
Tool0 = Instance.new("Tool")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
Part3 = Instance.new("Part")
RemoteEvent4 = Instance.new("RemoteEvent")
Script5 = Instance.new("Script")
RemoteEvent6 = Instance.new("RemoteEvent")
Script7 = Instance.new("Script")
Sound8 = Instance.new("Sound")
Sound9 = Instance.new("Sound")
LocalScript10 = Instance.new("LocalScript")
Script11 = Instance.new("Script")
Part12 = Instance.new("Part")
Part13 = Instance.new("Part")
SpecialMesh14 = Instance.new("SpecialMesh")
Part15 = Instance.new("Part")
SpecialMesh16 = Instance.new("SpecialMesh")
Weld17 = Instance.new("Weld")
Weld18 = Instance.new("Weld")
Tool0.Name = "ebony and ivory"
Tool0.Parent = owner.Backpack
Tool0.CanBeDropped = false
Tool0.Grip = CFrame.new(-0.652330399, -0.0610647202, -0.0560054779, -3.72527154e-07, 5.13156181e-07, -1, -1.91154257e-07, 1, 5.13156238e-07, 1, 1.91154442e-07, -3.72527069e-07)
Tool0.GripForward = Vector3.new(1, -5.131562375026988e-07, 3.725270687482407e-07)
Tool0.GripPos = Vector3.new(-0.6523303985595703, -0.061064720153808594, -0.05600547790527344)
Tool0.GripRight = Vector3.new(-3.72527154013369e-07, -1.9115425686777598e-07, 1)
Tool0.GripUp = Vector3.new(5.131561806592799e-07, 1, 1.9115444160888728e-07)
Tool0.RequiresHandle = false
Part1.Name = "BulletDrop2"
Part1.Parent = Tool0
Part1.CFrame = CFrame.new(-16.6887188, 2.68609929, -26.4170322, 1, 0, -2.00013492e-05, 0, 1, 0, 2.00013492e-05, 0, 1)
Part1.Position = Vector3.new(-16.688718795776367, 2.6860992908477783, -26.41703224182129)
Part1.Transparency = 1
Part1.Size = Vector3.new(0.5, 0.5, 0.5)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.CanCollide = false
Part1.TopSurface = Enum.SurfaceType.Smooth
Part2.Name = "End2"
Part2.Parent = Tool0
Part2.CFrame = CFrame.new(-14.9251184, 2.6319015, -26.8328381, -1, 0, 2.00013492e-05, 0, 1, 0, -2.00013492e-05, 0, -1)
Part2.Orientation = Vector3.new(0, 180, 0)
Part2.Position = Vector3.new(-14.925118446350098, 2.631901502609253, -26.83283805847168)
Part2.Rotation = Vector3.new(-180, 0, -180)
Part2.Transparency = 1
Part2.Size = Vector3.new(0.5, 0.5, 0.5)
Part2.BottomSurface = Enum.SurfaceType.Smooth
Part2.TopSurface = Enum.SurfaceType.Smooth
Part3.Name = "BulletDrop"
Part3.Parent = Tool0
Part3.CFrame = CFrame.new(-16.6387215, 2.58609915, -23.7801991, 1, 0, -2.00013492e-05, 0, 1, 0, 2.00013492e-05, 0, 1)
Part3.Position = Vector3.new(-16.638721466064453, 2.586099147796631, -23.78019905090332)
Part3.Transparency = 1
Part3.Size = Vector3.new(0.5, 0.5, 0.5)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.CanCollide = false
Part3.TopSurface = Enum.SurfaceType.Smooth
RemoteEvent4.Parent = Tool0
Script5.Parent = Tool0
RemoteEvent6.Name = "Rage"
RemoteEvent6.Parent = Tool0
Script7.Name = "InstaWeld"
Script7.Parent = Tool0
Sound8.Name = "Fire"
Sound8.Parent = Tool0
Sound8.SoundId = "rbxassetid://7295970591"
Sound9.Name = "Reload"
Sound9.Parent = Tool0
Sound9.SoundId = "rbxassetid://2920960"
Part12.Name = "End"
Part12.Parent = Tool0
Part12.CFrame = CFrame.new(-14.9251184, 2.6319015, -23.3828354, -1, 0, 2.00013492e-05, 0, 1, 0, -2.00013492e-05, 0, -1)
Part12.Orientation = Vector3.new(0, 180, 0)
Part12.Position = Vector3.new(-14.925118446350098, 2.631901502609253, -23.382835388183594)
Part12.Rotation = Vector3.new(-180, 0, -180)
Part12.Transparency = 1
Part12.Size = Vector3.new(0.5, 0.5, 0.5)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.TopSurface = Enum.SurfaceType.Smooth
Part13.Name = "Handle2"
Part13.Parent = Tool0
Part13.CFrame = CFrame.new(-16.3360004, 2.30999994, -26.8659992, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part13.Position = Vector3.new(-16.336000442504883, 2.309999942779541, -26.865999221801758)
Part13.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part13.Size = Vector3.new(2.3269999027252197, 1.2200000286102295, 0.2680000066757202)
Part13.BottomSurface = Enum.SurfaceType.Smooth
Part13.BrickColor = BrickColor.new("Institutional white")
Part13.TopSurface = Enum.SurfaceType.Smooth
Part13.brickColor = BrickColor.new("Institutional white")
SpecialMesh14.Parent = Part13
SpecialMesh14.MeshId = "rbxassetid://13332356591"
SpecialMesh14.MeshType = Enum.MeshType.FileMesh
Part15.Name = "Handle"
Part15.Parent = Tool0
Part15.CFrame = CFrame.new(-16.3360004, 2.30999994, -23.3660011, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part15.Position = Vector3.new(-16.336000442504883, 2.309999942779541, -23.36600112915039)
Part15.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part15.Size = Vector3.new(2.3269999027252197, 1.2200000286102295, 0.2680000066757202)
Part15.BottomSurface = Enum.SurfaceType.Smooth
Part15.BrickColor = BrickColor.new("Really black")
Part15.TopSurface = Enum.SurfaceType.Smooth
Part15.brickColor = BrickColor.new("Really black")
SpecialMesh16.Parent = Part15
SpecialMesh16.MeshId = "rbxassetid://13332356591"
SpecialMesh16.MeshType = Enum.MeshType.FileMesh
Weld17.Parent = Part15
Weld17.C0 = CFrame.new(0, 0, -0.134000778, 1, 0, 0, 0, -1, 0, 0, 0, -1)
Weld17.C1 = CFrame.new(0.302726746, -0.276099205, 0.280191422, 1, 0, -2.00013492e-05, 0, -1, 0, -2.00013492e-05, 0, -1)
Weld17.Part0 = Part15
Weld17.Part1 = Part3
Weld17.part1 = Part3
Weld18.Parent = Part15
Weld18.C0 = CFrame.new(1.16349983, 0, 1.90734863e-06, 0, 0, 1, 0, -1, 0, 1, 0, 0)
Weld18.C1 = CFrame.new(0.247382164, -0.32190156, -0.0168418884, -2.00013492e-05, -0, -1, 0, -1, 0, -1, 0, 2.00013492e-05)
Weld18.Part0 = Part15
Weld18.Part1 = Part12
Weld18.part1 = Part12
NS([[local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local Tool = script.Parent
local Handle = Tool:FindFirstChild("Handle")
local ShootPart = Handle:FindFirstChild("Attachment")
local RemoteEvent = Tool:WaitForChild("RemoteEvent")
local OnCooldown = false

local turn = 1

local reloading = false

local Do = {
	Damage = 25;
	Cooldown = 0;
	Visualize = true;
	ShootSound = script.Parent.Fire.SoundId;
	ReloadSound = script.Parent.Reload.SoundId;
	MaxAmmo = math.huge;
	Ammo = math.huge;
}

function CalculateNeededAmmo(Ammo)
	local x = Do.MaxAmmo - Ammo
	return x
end

local pressed = false


local theme = Instance.new("Sound",Handle)
theme.SoundId = "rbxassetid://13299215420"
theme.Volume = .45

Tool.Equipped:Connect(function()
	theme:Play()
end)

Tool.Unequipped:Connect(function()
	theme:Play()
end)


tween = function(speed, easingstyle, easingdirection, loopcount, WHAT, goal)
	local info = TweenInfo.new(
		speed,
		easingstyle,
		easingdirection,
		loopcount
	)
	local goals = goal
	local anim = game:GetService("TweenService"):Create(WHAT, info, goals)
	anim:Play()
end

makepart = function(parent, size, cf, anchored, cancol, name) --spawnlocation because spawns have less limit on vsb
	local part = Instance.new("SpawnLocation")
	part.Enabled = false
	part.Anchored = anchored
	part.CanCollide = cancol
	part.Name = name or "Part"
	part.Size = size
	part.CFrame = cf
	part.Parent = parent
	part:BreakJoints()
	return part
end




local pelletCount = 7 --The number of pellets you want being shot
local maximumOffset = 5 --The maximum number of studs that the bullets will offset at
local RNG = Random.new()


local burst = false
local rage = false
local burstwait = 0.5


spawn(function()
	while rage == true do
		wait(0.5)
		Do.Damage = 50
	end
end)


spawn(function()
	script.Parent.Rage.OnServerEvent:Connect(function()
		rage = true
		burstwait = 0.3
		wait(15)
		rage = false
		burstwait = 0.5
	end)
end)

RemoteEvent.OnServerEvent:Connect(function(Player,Received,MTarget) -- Main fire function
	
	if not OnCooldown then -- if not cooldown
		OnCooldown = true
		task.delay(Do.Cooldown,function()
			OnCooldown = false
		end)
		if Do.Ammo > 0 and not reloading then -- check if the ammo count is not 0 and the gun is not realoded
			if turn == 1 then
				local Origin = ShootPart.WorldPosition
				local Direction = (Received.Position-Origin).Unit*500 -- raycast stuff don't mind
				local Raycast = workspace:Raycast(Origin,Direction)

				local Intersection = Raycast and Raycast.Position or Origin + Direction
				local Distance = (Origin - Intersection).Magnitude
				if rage == false then
					local Visualizer = Instance.new("Part")
					Visualizer.CanTouch = false
					Visualizer.CanCollide = false
					Visualizer.CanQuery = false
					Visualizer.CastShadow = false
					Visualizer.Anchored = true
					Visualizer.Material = Enum.Material.Neon
					Visualizer.Color = Color3.fromRGB(255, 255, 0)
					Visualizer.Size = Vector3.new(.15,.15,Distance)
					Visualizer.CFrame = CFrame.new(Origin, Intersection)*CFrame.new(0,0,-Distance/2)
					if Do.Visualize == true then -- Makes the "bullet" trail it's just a yellow part
						Visualizer.Parent = workspace
						TweenService:Create(Visualizer,TweenInfo.new(.3),{Transparency = 1, Size = Vector3.new(0,0,Distance)}):Play()
						Debris:AddItem(Visualizer,.35)
					end
				elseif rage == true then
					local Visualizer = Instance.new("Part")
					Visualizer.CanTouch = false
					Visualizer.CanCollide = false
					Visualizer.CanQuery = false
					Visualizer.CastShadow = false
					Visualizer.Anchored = true
					Visualizer.Material = Enum.Material.Neon
					Visualizer.Color = Color3.fromRGB(255, 57, 8)
					Visualizer.Size = Vector3.new(.15,.15,Distance)
					Visualizer.CFrame = CFrame.new(Origin, Intersection)*CFrame.new(0,0,-Distance/2)
					if Do.Visualize == true then -- Makes the "bullet" trail it's just a yellow part
						Visualizer.Parent = workspace
						TweenService:Create(Visualizer,TweenInfo.new(.3),{Transparency = 1, Size = Vector3.new(0,0,Distance)}):Play()
						Debris:AddItem(Visualizer,.35)
					end
				
				end
				local shell = Instance.new("Part",workspace)
				shell.BrickColor = BrickColor.new("Gold")
				shell.Material = "Metal"
				shell.Shape = Enum.PartType.Cylinder
				shell.Size = Vector3.new(0.445, 0.151, 0.151)
				shell.Position = script.Parent.BulletDrop.Position
				Debris:AddItem(shell,3)

			

				if (Do.ShootSound ~= "" or Do.ShootSound ~= nil) then -- fire visualiser
					local Sound = Instance.new("Sound")
					local shockwave = makepart(
						workspace,
						Vector3.new(),
						Tool.End.CFrame * CFrame.new(-0.5,0,0) * CFrame.Angles(math.pi/2,0,math.pi/2),
						true,
						false
					)
					local ring = makepart(
						workspace,
						Vector3.new(),
						Tool.End.CFrame * CFrame.Angles(0,math.pi/2,0),
						true,
						false
					)
					local shockmesh = Instance.new("SpecialMesh", shockwave)
					shockmesh.VertexColor = Vector3.new(20,20,20)
					shockmesh.MeshId = "rbxassetid://20329976"
					local ringmesh = Instance.new("SpecialMesh", ring)
					ringmesh.VertexColor = Vector3.new(20,20,20)
					ringmesh.MeshId = "rbxassetid://3270017"
					shockwave.CanQuery = false
					shockwave.CanTouch = false
					ring.CanQuery = false
					ring.CanTouch = false
					
					if rage == false then
						shockwave.Color = Color3.fromRGB(255, 226, 6)
						ring.Color = Color3.fromRGB(255, 226, 6)
						local ligh = Instance.new("PointLight", Handle)
						ligh.Brightness = 5
						ligh.Range = 15
						ligh.Color = Color3.fromRGB(255, 226, 6)
						Debris:AddItem(ligh, 0.025)
					elseif rage == true then
						shockwave.Color = Color3.fromRGB(255, 57, 8)
						ring.Color = Color3.fromRGB(255, 57, 8)
						shockwave.Material = "Neon"
						ring.Material = "Neon"
						local ligh = Instance.new("PointLight", script.Parent.Handle2)
						ligh.Brightness = 5
						ligh.Range = 15
						ligh.Color = Color3.fromRGB(255, 57, 8)
						Debris:AddItem(ligh, 0.025)
					end
					tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, shockmesh, {Scale = Vector3.new(1,0,1)})
					tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, shockwave, {Transparency = 1})
					tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, ringmesh, {Scale = Vector3.new(2.5,2.5,0)})
					tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, ring, {Transparency = 1})
					
					Debris:AddItem(ring, 0.15)
					Debris:AddItem(shockwave, 0.15)
			
					Sound.SoundId = Do.ShootSound
					Sound.Volume = .65
					Sound.PlayOnRemove = true
					Sound.Parent = Handle
					Sound:Destroy()
					local animid = nil
					local hum = script.Parent.Parent:FindFirstChildWhichIsA("Humanoid")

				end

				if Raycast then -- hitscan
					local Hit:Part = Raycast.Instance
					local Humanoid = (Hit.Parent:FindFirstChildOfClass("Humanoid") or Hit.Parent.Parent:FindFirstChildOfClass("Humanoid"))

					if Humanoid and Humanoid.Parent ~= Player.Character then
						Humanoid:TakeDamage(Do.Damage)
					end
				end
				turn +=1
				
			elseif turn == 2 then
				if burst == false then
					burst =true
				
				for i = 1,3 do
					wait(0.2)
					local Origin = ShootPart.WorldPosition
					local Direction = (Received.Position-Origin).Unit*150 -- raycast stuff don't mind
					local Raycast = workspace:Raycast(Origin,Direction)

					local Intersection = Raycast and Raycast.Position or Origin + Direction
					local Distance = (Origin - Intersection).Magnitude
					
				
					
					local pelletSpread = Origin + Direction +Vector3.new(RNG:NextNumber(-maximumOffset, maximumOffset), RNG:NextNumber(-maximumOffset, maximumOffset), RNG:NextNumber(-maximumOffset, maximumOffset))  --Create a Vector3 that consists of a randomization of all the axes.
						
						if rage == false then
							local Visualizer = Instance.new("Part")
							Visualizer.CanTouch = false
							Visualizer.CanCollide = false
							Visualizer.CanQuery = false
							Visualizer.CastShadow = false
							Visualizer.Anchored = true
							Visualizer.Material = Enum.Material.Neon
							Visualizer.Color = Color3.fromRGB(255, 255, 0)
							Visualizer.Size = Vector3.new(.15,.15,Distance)
							Visualizer.CFrame = CFrame.new(script.Parent.Handle2.Attachment.WorldPosition, pelletSpread)*CFrame.new(0,0,-Distance/2)
							if Do.Visualize == true then -- Makes the "bullet" trail it's just a yellow part
								Visualizer.Parent = workspace
								TweenService:Create(Visualizer,TweenInfo.new(.3),{Transparency = 1, Size = Vector3.new(0,0,Distance)}):Play()
								Debris:AddItem(Visualizer,.35)
							end
						elseif rage == true then
							local Visualizer = Instance.new("Part")
							Visualizer.CanTouch = false
							Visualizer.CanCollide = false
							Visualizer.CanQuery = false
							Visualizer.CastShadow = false
							Visualizer.Anchored = true
							Visualizer.Material = Enum.Material.Neon
							Visualizer.Color = Color3.fromRGB(255, 57, 8)
							Visualizer.Size = Vector3.new(.15,.15,Distance)
							Visualizer.CFrame = CFrame.new(script.Parent.Handle2.Attachment.WorldPosition, pelletSpread)*CFrame.new(0,0,-Distance/2)
							if Do.Visualize == true then -- Makes the "bullet" trail it's just a yellow part
								Visualizer.Parent = workspace
								TweenService:Create(Visualizer,TweenInfo.new(.3),{Transparency = 1, Size = Vector3.new(0,0,Distance)}):Play()
								Debris:AddItem(Visualizer,.35)
							end
						end
					
					local shell = Instance.new("Part",workspace)
					shell.BrickColor = BrickColor.new("Gold")
					shell.Material = "Metal"
					shell.Shape = Enum.PartType.Cylinder
					shell.Size = Vector3.new(0.445, 0.151, 0.151)
					shell.Position = script.Parent.BulletDrop2.Position
					Debris:AddItem(shell,3)

				

					if (Do.ShootSound ~= "" or Do.ShootSound ~= nil) then -- fire visualiser
						local Sound = Instance.new("Sound")
						local shockwave = makepart(
							workspace,
							Vector3.new(),
							Tool.End2.CFrame * CFrame.new(-0.5,0,0) * CFrame.Angles(math.pi/2,0,math.pi/2),
							true,
							false
						)
						local ring = makepart(
							workspace,
							Vector3.new(),
							Tool.End2.CFrame * CFrame.Angles(0,math.pi/2,0),
							true,
							false
						)
						local shockmesh = Instance.new("SpecialMesh", shockwave)
						shockmesh.VertexColor = Vector3.new(20,20,20)
						shockmesh.MeshId = "rbxassetid://20329976"
						local ringmesh = Instance.new("SpecialMesh", ring)
						ringmesh.VertexColor = Vector3.new(20,20,20)
						ringmesh.MeshId = "rbxassetid://3270017"
						shockwave.CanQuery = false
						shockwave.CanTouch = false
						
						ring.CanQuery = false
						ring.CanTouch = false
							
							if rage == false then
								shockwave.Color = Color3.fromRGB(255, 226, 6)
								ring.Color = Color3.fromRGB(255, 226, 6)
								local ligh = Instance.new("PointLight", script.Parent.Handle2)
								ligh.Brightness = 5
								ligh.Range = 15
								ligh.Color = Color3.fromRGB(255, 226, 6)
								Debris:AddItem(ligh, 0.025)
							elseif rage == true then
								shockwave.Color = Color3.fromRGB(255, 57, 8)
								ring.Color = Color3.fromRGB(255, 57, 8)
								shockwave.Material = "Neon"
								ring.Material = "Neon"
								local ligh = Instance.new("PointLight", script.Parent.Handle2)
								ligh.Brightness = 5
								ligh.Range = 15
								ligh.Color = Color3.fromRGB(255, 57, 8)
								Debris:AddItem(ligh, 0.025)
							end
						tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, shockmesh, {Scale = Vector3.new(1,0,1)})
						tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, shockwave, {Transparency = 1})
						tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, ringmesh, {Scale = Vector3.new(2.5,2.5,0)})
						tween(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, ring, {Transparency = 1})
						Debris:AddItem(ring, 0.15)
						Debris:AddItem(shockwave, 0.15)
						Sound.SoundId = Do.ShootSound
						Sound.Volume = .65
						Sound.PlayOnRemove = true
						Sound.Parent = Handle
						Sound:Destroy()
						local animid = nil
						local hum = script.Parent.Parent:FindFirstChildWhichIsA("Humanoid")

					end

					if Raycast then -- hitscan
						local Hit:Part = Raycast.Instance
						local Humanoid = (Hit.Parent:FindFirstChildOfClass("Humanoid") or Hit.Parent.Parent:FindFirstChildOfClass("Humanoid"))

						if Humanoid and Humanoid.Parent ~= Player.Character then
							Humanoid:TakeDamage(Do.Damage)
						end
					end
					end
					wait(burstwait)
				burst = false
				turn-=1
			end
		end
		end
	end
end)]],Tool0)





LocalScript10.Parent = Tool0
NLS([[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

local Tool = script.Parent
local RemoteEvent = script.Parent:WaitForChild("RemoteEvent")

local rage = Tool.Rage


function Send() -- send Mouse position to server
	RemoteEvent:FireServer({Position = Mouse.Hit.Position},Mouse.Target)
end



local uis = game:GetService("UserInputService")
local using = false
local cooldown = 0.25
local reloading = true



uis.InputBegan:Connect(function(k) 
	if reloading == true then
		if k.KeyCode == Enum.KeyCode.E then
			reloading = false
			rage:FireServer()
			cooldown = 0.15
			spawn(function()
				wait(15)
				cooldown = 0.25
			end)
			wait(30)
			reloading = true
		end
	end
end)


script.Parent.Activated:Connect(function() -- Fire function
	while uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
		wait(0)
		if using == false  then
			using = true
			Send()
			wait(cooldown)
			using = false
		end
	end	
end)

Tool.Deactivated:Connect(function()

end)

Tool.Unequipped:Connect(function()

end)



Tool.Equipped:Connect(function()
	reloading = true
end)

Tool.Unequipped:Connect(function()
	reloading = false
end)
]],Tool0)
Script11.Name = "qPerfectionWeld"
Script11.Parent = Tool0
NS([[

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).]])


